 mespsy_df = pd.read_csv(SYNTH_FIL)
nonhab_df = pd.read_csv('data/nonhab.csv').drop(['P. Name'], axis=1)

if SYNTH_FIL == 'data/gouri_data.csv':
    mespsy_df.drop(['P. Name'], axis=1)

partitions = {
    'meso': np.array(mespsy_df[mespsy_df[LABEL_COL] == 2]),
    'psyc': np.array(mespsy_df[mespsy_df[LABEL_COL] == 3]),
    'nonh': np.array(nonhab_df.sample(1000))
}


def shuffle_and_split_data(data):
    '''Shuffles each class contained in data and splits into train and
    test sets at a ratio of 7:3. Returns numpy arrays for the resulting
    data sets.
    '''
    train_l = []
    tests_l = []
    for val in data.values():
        np.random.shuffle(val)
        tr, te = np.split(val, [int(.7 * len(val))])
        train_l.append(tr)
        tests_l.append(te)

    train_ar = np.vstack(train_l)
    tests_ar = np.vstack(tests_l)

    np.random.shuffle(train_ar)
    np.random.shuffle(tests_ar)

    return train_ar, tests_ar


def run_test(partitions, clf):
    '''Runs 1/4th of the total inner iterations.'''
    conf_mat = np.zeros(shape=(3, 3))
    for inner_it in range(TOTAL_INN // 4):
        tr, te = shuffle_and_split_data(partitions)
        clf.fit(tr[:, 1:], tr[:, 0])
        ypred = clf.predict(te[:, 1:])
        conf_mat += confusion_matrix(te[:, 0], ypred)
    return conf_mat


info = [['Algorithm', 'Class', 'Sensitivity', 'Specificity', 'Precision',
         'Accuracy']]
for algo, clf in algorithms.items():
    print(':: Testing', algo, '...')
    status = '  => Outer Iteration: ({:>02}/' + str(TOTAL_OUT) + ')'

    conf_mat = np.zeros(shape=(3, 3))
    for outer_it in range(TOTAL_OUT):
        # Draw a new set of non habitable samples.
        partitions['nonh'] = np.array(nonhab_df.sample(1000))

        # Run inner iterations on 4 workers. Each worker runs
        # TOTAL_INN // 4 iterations.
        with ProcessPoolExecutor(max_workers=4) as executor:
            res = [executor.submit(run_test, partitions, clf)
                   for inner_it in range(4)]

        # Retrieve the result from the Future object.
        conf_mat = np.zeros(shape=(3, 3))
        for r in res:
            conf_mat += r.result()

        print(status.format(outer_it+1), end='\r')

    print('\n  => Accuracy:', np.trace(conf_mat) / np.sum(conf_mat))

    # Constructing the data list for algo.
    _notc = np.array([True, True, True])
    _classes = ['Non Habitable', 'Mesoplanet', 'Psychroplanet']
    for c, cname in enumerate(_classes):
        _notc[c] = False
        tp = conf_mat[c, c]
        tn = np.sum(conf_mat[_notc, _notc])
        fp = np.sum(conf_mat[_notc, c])
        fn = np.sum(conf_mat[c, _notc])
        _notc[c] = True

        sens = tp / (tp + fn)
        spec = tn / (tn + fp)
        prec = tp / (tp + fp)
        accy = (tp + tn) / (tp + fn + tn + fp)

        info.append([algo, cname, sens, spec, prec, accy])

with open(OUTPT_FIL, 'w', newline='') as csvfile:
    wr = csv.writer(csvfile)
    for row in info:
        wr.writerow(row)
